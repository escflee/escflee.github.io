
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.10">
    
    
      
        <title>C++基础 - escflee的博客</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.472b142f.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.08040f6c.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="None" data-md-color-accent="None">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="escflee的博客" class="md-header__button md-logo" aria-label="escflee的博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            escflee的博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              C++基础
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="escflee的博客" class="md-nav__button md-logo" aria-label="escflee的博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    escflee的博客
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          课程笔记
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="课程笔记" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          课程笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_1_1" type="checkbox" id="__nav_1_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1_1">
          算法设计与分析
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="算法设计与分析" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_1">
          <span class="md-nav__icon md-icon"></span>
          算法设计与分析
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E4%B8%BB%E5%AE%9A%E7%90%86/" class="md-nav__link">
        主定理
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_1_2" type="checkbox" id="__nav_1_2" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1_2">
          操作系统
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="操作系统" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_2">
          <span class="md-nav__icon md-icon"></span>
          操作系统
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%A6%82%E8%BF%B0/" class="md-nav__link">
        概述
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="md-nav__link">
        进程管理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="md-nav__link">
        内存管理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" class="md-nav__link">
        文件管理
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_1_3" type="checkbox" id="__nav_1_3" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1_3">
          编译原理
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="编译原理" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_3">
          <span class="md-nav__icon md-icon"></span>
          编译原理
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/" class="md-nav__link">
        词法分析
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/" class="md-nav__link">
        语法分析
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_1_4" type="checkbox" id="__nav_1_4" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_1_4">
          数据库
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="数据库" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_4">
          <span class="md-nav__icon md-icon"></span>
          数据库
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/SQL/" class="md-nav__link">
        SQL
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/" class="md-nav__link">
        关系模型
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_2">
          编程语言
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="编程语言" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          编程语言
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_2_1" type="checkbox" id="__nav_2_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_2_1">
          C
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="C" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          C
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../C/C%E5%9F%BA%E7%A1%80/" class="md-nav__link">
        C基础
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_2_2" type="checkbox" id="__nav_2_2" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_2_2">
          C++
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="C++" data-md-level="2">
        <label class="md-nav__title" for="__nav_2_2">
          <span class="md-nav__icon md-icon"></span>
          C++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          C++基础
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        C++基础
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    变量初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    强制类型转换
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    引用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    动态内存分配
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="md-nav__link">
        面向对象程序设计
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3">
          算法题
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="算法题" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          算法题
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_3_1" type="checkbox" id="__nav_3_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_3_1">
          典型算法
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="典型算法" data-md-level="2">
        <label class="md-nav__title" for="__nav_3_1">
          <span class="md-nav__icon md-icon"></span>
          典型算法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E7%AE%97%E6%B3%95%E9%A2%98/%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/" class="md-nav__link">
        排序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../%E7%AE%97%E6%B3%95%E9%A2%98/%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/" class="md-nav__link">
        搜索
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    变量初始化
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    强制类型转换
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    引用
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    动态内存分配
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">数据存储<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<h2 id="_2">变量初始化<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h2>
<p>c++中允许使用这种更简单的形式在声明变量时初始化，当类中定义了构造函数时也可以适用：</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">i</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span><span class="w"></span>

<span class="n">A</span><span class="o">::</span><span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="c1">//类A的构造函数</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<h2 id="_3">强制类型转换<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="c1">//两种格式都可以</span>
<span class="n">c</span><span class="o">=</span><span class="kt">float</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">a</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h2 id="_4">引用<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h2>
<ul>
<li>引用(&amp;)相当于为已有变量取别名，声明时必须初始化，且无法再改变。用关键字const限定时，被引用的对象不能被更新。只有用const限定时才可以引用一个常量。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="c1">//&amp;符号仅起到标识作用</span>
<span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="c1">//相当于a=10</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="c1">//无法通过c改变a的值</span>
</code></pre></div>
<ul>
<li>函数中使用引用变量作为形参时，表示调用函数时这个参数采用引用传递，函数内将能直接改动原数据。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="c1">//执行后a,b实现交换</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>函数使用引用变量作为形参，但用关键字const修饰时，被引用的对象不能被更新。</li>
<li>函数使用引用变量作为返回值，好处在于不会在内存中产生返回值的副本，且函数返回后可以被赋值。此时返回对象不能是函数中的临时变量，而应该是静态变量、全局变量等函数返回后不会被销毁的数据。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">func1</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//return b;不能返回临时变量</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="err">；</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">func1</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="c1">//引用变量作为返回值时可以被赋值</span>

<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="nf">func2</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="n">func2</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="c1">//用const修饰的引用变量无法被赋值</span>
</code></pre></div>
<h2 id="_5">动态内存分配<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h2>
<ul>
<li>申请内存：new 类型名(初值列表)</li>
</ul>
<p>返回值为该类型的指针，分配失败时返回NULL</p>
<ul>
<li>释放内存：delete 指针</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span><span class="c1">//赋初始值为2</span>
<span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>

<span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="c1">//申请一个int数组</span>
<span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<ul>
<li>动态分配二维数组</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">//动态分配M*N维</span>
<span class="kt">int</span><span class="w"> </span><span class="o">**</span><span class="n">a</span><span class="o">=</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">[</span><span class="n">M</span><span class="p">];</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">N</span><span class="p">];</span><span class="w"></span>
<span class="c1">//动态释放</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
</code></pre></div>
<h1 id="_6">函数<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h1>
<h2 id="_7">内联函数<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h2>
<p>将函数声明为内联函数(inline)时，编译后函数执行时会直接用语句直接替换，不会产生调用函数所需的开销。</p>
<div class="highlight"><pre><span></span><code><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_8">默认参数<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h2>
<p>函数声明时可以给出默认形参的默认值，调用时没有给出实参则会使用这个默认值。</p>
<p>函数调用时会自动将实参从左到右分配到形参，因此默认形参值必须从右到左给出。</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span><span class="c1">//10+20</span>
<span class="w">    </span><span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="c1">//10+6</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_9">函数重载<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h2>
<p>函数重载(function overloading)指名称相同，但参数个数或类型不同的函数可以同时声明。const关键字也可用来区分重载函数，此时const对象只能调用const函数，非const对象优先调用非const函数。</p>
<div class="highlight"><pre><span></span><code><span class="c1">//用参数类型或个数区分重载函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="kt">double</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>

<span class="c1">//用const关键字区分重载函数</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
</code></pre></div>
<h1 id="_10">类<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h1>
<h2 id="_11">声明<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">类名称</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">公有成员</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">私有成员</span><span class="p">(</span><span class="n">只有本类对象可以访问</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">保护型成员</span><span class="p">(</span><span class="n">只有本类及其派生类成员可以访问</span><span class="p">)</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<ul>
<li>
<p>当未声明访问类型时，默认为private。(struct默认为public)</p>
</li>
<li>
<p>在类的声明中一般只给出函数原型，而函数体放置在类声明的外部。</p>
</li>
<li>
<p>函数体放置在类声明的内部时，表示该函数为内联函数。</p>
</li>
<li>
<p>函数体放置在类声明的外部时，需在函数名前加上类名进行限定。</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Clock</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">SetTime</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">NewHour</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NewMin</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NewSec</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">ShowTime</span><span class="p">()</span><span class="c1">//内联函数</span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">Hour</span><span class="o">&lt;&lt;</span><span class="s">&quot;:&quot;</span><span class="o">&lt;&lt;</span><span class="n">Hminute</span><span class="o">&lt;&lt;</span><span class="s">&quot;:&quot;</span><span class="o">&lt;&lt;</span><span class="n">Second</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">Hour</span><span class="p">,</span><span class="w"> </span><span class="n">Minute</span><span class="p">,</span><span class="w"> </span><span class="n">Second</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">Clock::SetTime</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">NewHour</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NewMin</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">NewSec</span><span class="p">)</span><span class="c1">//函数名前加类名加以限制</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Hour</span><span class="o">=</span><span class="n">NewHour</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Minute</span><span class="o">=</span><span class="n">NewMin</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Second</span><span class="o">=</span><span class="n">NewSec</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_12">前向引用声明<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h2>
<p>类似于函数原型的功能，类的前向引用声明可以使得在未给出类的完整定义时使用类。但是，只能使用被声明的符号，不能涉及类的任何内部细节，如定义该类的对象、使用该类的成员。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="p">;</span><span class="c1">//前向引用声明</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="c1">//有前向引用声明，此处用法正确</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="n">aa</span><span class="p">;</span><span class="c1">//错误，类没有完整定义，无法定义对象</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_13">指针<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h2>
<ul>
<li>this指针（自引用）：在类的内部存在一个隐含参数this，调用时指向该对象。在对象中使用该对象内的成员时无需添加对象名，自动隐含this指针。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Clock::Function</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Second</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//等同于</span>
<span class="w">    </span><span class="c1">//this-&gt;Second++;</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_14">构造函数<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h2>
<ul>
<li>constructor</li>
<li>用于对象创建时的初始化。</li>
<li>名字与类名相同。</li>
<li>没有返回值。(也不是void)</li>
<li>未声明时系统会自动产生。</li>
<li>允许内联、重载、默认形参值。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Clock</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">Clock</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Hour</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Min</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Sec</span><span class="p">);</span><span class="c1">//名称与类名相同</span>
<span class="w">    </span><span class="nl">ptivate</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">Hour</span><span class="p">,</span><span class="w"> </span><span class="n">Minute</span><span class="p">,</span><span class="w"> </span><span class="n">Second</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">Clock</span><span class="o">::</span><span class="n">Clock</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">Hour</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Min</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">Sec</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Hour</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Hour</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Minute</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Min</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Second</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Sec</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Clock</span><span class="w"> </span><span class="nf">MyClock</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//调用构造函数</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_15">拷贝构造函数<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h2>
<ul>
<li>copy constructor</li>
<li>参数为指向该类对象的引用。</li>
<li>用于：利用已有对象初始化新声明的变量、调用函数时按值传递对象参数、返回值为类对象时。</li>
<li>编译器会自动生成拷贝构造函数，但可能是不正确的，例如存在指针的情况。</li>
<li>参数必须是引用类型的原因：当对象以值传递时，会默认调用拷贝构造函数用于生成副本，如果连拷贝构造函数都是值传递，会造成死循环。</li>
<li>参数用const的原因：并不一定要用const，但由于参数使用了引用，且函数的用途是复制，并不需要改变原对象，通常要使用const来避免不必要的修改。同时，使用const使得函数也可以使用常量变量作为参数。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">Clock</span><span class="o">::</span><span class="n">Clock</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="c1">//令参数为const类型，提高安全性</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Hour</span><span class="o">=</span><span class="n">C</span><span class="p">.</span><span class="n">Hour</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Minute</span><span class="o">=</span><span class="n">C</span><span class="p">.</span><span class="n">Minute</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Second</span><span class="o">=</span><span class="n">C</span><span class="p">.</span><span class="n">Second</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">Clock</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w"></span>
<span class="n">Clock</span><span class="w"> </span><span class="nf">b</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="c1">//调用拷贝构造函数</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">func1</span><span class="p">(</span><span class="n">Class</span><span class="w"> </span><span class="n">C</span><span class="p">)</span><span class="c1">//调用拷贝构造函数</span>

<span class="kt">void</span><span class="w"> </span><span class="n">func2</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Clock</span><span class="w"> </span><span class="n">C</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">C</span><span class="p">;</span><span class="c1">//调用拷贝构造函数</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_16">组合类的构造函数<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h2>
<ul>
<li>用于类的成员是另一个类的对象时对象的初始化。</li>
<li>调用后能同时完成本类中基本类型成员的初始化和对象成员的初始化。</li>
<li>和普通的构造函数基本相同，区别在于其函数体开头要单独描述各个对象成员的初始化方式。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">声明格式</span><span class="err">：</span><span class="w"></span>
<span class="n">类名</span><span class="o">::</span><span class="n">类名</span><span class="p">(</span><span class="n">参数表</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="n">成员</span><span class="p">(</span><span class="n">初始化参数</span><span class="p">),</span><span class="n">成员</span><span class="p">(</span><span class="n">初始化参数</span><span class="p">),...</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">本类初始化</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">point</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">line</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">point</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">line</span><span class="o">::</span><span class="n">line</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y1</span><span class="p">,</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="n">p1</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">),</span><span class="n">p2</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="c1">//未列出的对象成员会使用默认构造函数</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_17">析构函数<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h2>
<ul>
<li>destructor</li>
<li>用于对象生存周期结束后自动完成善后工作，如释放动态申请的内存空间、关闭打开的文件。</li>
<li>系统一定条件下会自动生成。</li>
<li>函数名为类名前面加波浪号。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">Class</span><span class="w"> </span><span class="n">MyClass</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="n">MyClass</span><span class="o">::~</span><span class="n">MyClass</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_18">静态成员<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h2>
<ul>
<li>静态数据成员：用关键字static声明，必须在类的外部定义和初始化，类的所有对象共用该成员的同一个拷贝。</li>
<li>静态成员函数：用关键字static声明，只能引用属于该类的静态数据成员或静态成员函数。</li>
<li>静态数据成员和静态成员函数在没有实例化对象时都可以直接调用。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nl">prirate</span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="c1">//静态数据成员，用于记录一共生成了几个类的实例</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">Point</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">xx</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">yy</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">x</span><span class="o">=</span><span class="n">xx</span><span class="p">;</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="n">yy</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">GetC</span><span class="p">()</span><span class="c1">//静态成员函数</span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="n">Point</span><span class="o">::</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="c1">//静态数据成员的定义和初始化</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">GetC</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="c1">//没有类的实例时静态成员函数也可以调用</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="const">const修饰的对象成员<a class="headerlink" href="#const" title="Permanent link">&para;</a></h2>
<ul>
<li>常成员函数：用const修饰(位于形参表之后)的成员函数，不能改变对象的数据成员，不能调用非常量的成员函数。是否有const关键字可用于区分重载函数。无论在函数声明还是函数体，const都不能被省略。</li>
<li>常数据成员：不能被修改的数据成员。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">R</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="err">；</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">print</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="n">R2</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">R3</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_19">友元<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h2>
<ul>
<li>友元函数：类外的函数，在类的声明中用关键字friend修饰说明，就可以访问该类的所有成员(包括private/protected)。声明属于private、public还是protected都无所谓。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Point</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">Distance</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">Point</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="c1">//声明Distance函数是Point类的友元</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">double</span><span class="w"> </span><span class="nf">Distance</span><span class="p">(</span><span class="n">Point</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="n">Point</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="c1">//函数Distance不属于类Point</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dx</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">dy</span><span class="o">=</span><span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sprt</span><span class="p">(</span><span class="n">dx</span><span class="o">*</span><span class="n">dx</span><span class="o">+</span><span class="n">dy</span><span class="o">*</span><span class="n">dy</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>友元类：通过在类的声明中对另一个类进行友元声明，可以使另一个类的成员访问本类的所有成员。友元关系是单向的。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="p">;</span><span class="c1">//B可以访问A，但A不能访问B</span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<h1 id="_20">继承和派生<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h1>
<h2 id="_21">派生类的声明<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="c1">//格式为在派生类名后添加：继承方式 基类名</span>
<span class="k">class</span><span class="w"> </span><span class="nc">derived</span><span class="o">-</span><span class="k">class</span><span class="o">:</span><span class="w"> </span><span class="n">access</span><span class="o">-</span><span class="n">specifier</span><span class="w"> </span><span class="n">base</span><span class="o">-</span><span class="k">class</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="c1">//可以同时继承多个基类，如：</span>
<span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="k">private</span><span class="w"> </span><span class="n">C</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<h2 id="_22">继承方式<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h2>
<p>基类中的private成员派生类中的任何成员都不可访问。但对于public、protected成员，继承方式可以改变派生类对象对基类成员的访问方式。</p>
<p>基类成员在不同的继承方式下在派生类中新的访问类型如下：</p>
<table>
<thead>
<tr>
<th>继承方式\基类成员</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody>
<tr>
<td>public继承（最常用）</td>
<td>public</td>
<td>protected</td>
<td>不可访问</td>
</tr>
<tr>
<td>protected继承</td>
<td>protected</td>
<td>protected</td>
<td>不可访问</td>
</tr>
<tr>
<td>private继承（缺省）</td>
<td>private</td>
<td>private</td>
<td>不可访问</td>
</tr>
</tbody>
</table>
<ul>
<li>基类中的私有成员，派生类的成员函数、派生类外部均不可访问。</li>
<li>派生类的成员函数可以访问基类中的public、private成员。</li>
<li>基类被继承后其public、protected成员是否还能被外界访问、被再次继承，由继承方式决定。</li>
</ul>
<h2 id="_23">类型兼容规则<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h2>
<p>派生类是对基类的进一步细分，因此派生类属于基类，具有基类的特性。具体表现在；</p>
<ul>
<li>派生类对象可以用来赋值、初始化基类对象。</li>
<li>基类对象的指针、引用可以指向派生类对象。</li>
<li>基类对象的指针、引用即使指向一个派生类对象，也只能访问基类的对象。</li>
</ul>
<h2 id="_24">派生类的构造函数<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h2>
<p>基类的构造函数不会被继承，需要自己另外实现。但派生类的构造函数会默认调用基类的构造函数。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">B</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">B</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="c1">//C继承A、B</span>
<span class="k">class</span><span class="w"> </span><span class="nc">C</span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">B</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">);</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//派生类的构造函数可以直接调用基类的构造函数</span>
<span class="n">C</span><span class="o">::</span><span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="c1">//如果没有显式调用基类的构造函数，则会调用默认构造函数</span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>调用顺序为先按继承时声明的顺序调用基类的构造函数，然后执行成员对象的构造函数，最后执行构造函数函数体中的内容。</p>
<h2 id="_25">派生类的析构函数<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h2>
<p>基类的析构函数同样不会被继承，但在派生类的析构函数执行结束后会自动隐式调用，因此不需要在派生类的析构函数中显式调用。</p>
<p>基类的析构函数应该定义为虚函数。</p>
<p>调用顺序与构造函数相反，先执行派生类中的成员，再执行成员对象，最后执行基类。</p>
<h2 id="_26">同名隐藏规则<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h2>
<p>基类中的成员，包括数据、函数，会被派生类中的同名成员覆盖。但是，可以通过基类名进行限定来访问基类成员。</p>
<h1 id="_27">多态<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h1>
<h2 id="_28">运算符重载<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h2>
<p>运算符重载本质上是将c++中的运算符视为函数，重载他们在运算对象不同时的实现。运算符重载可分为类成员函数、类外函数。要注意当运算符重载为类外函数时，要根据数据访问的需要将其设为类的友元函数。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="c1">//类成员运算符重载隐含参数*this，如a-b相当于a.A::operator-(b)</span>
<span class="n">A</span><span class="w"> </span><span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tmp</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//类外运算符重载不隐含参数*this，a+b相当于operator+(a,b)</span>
<span class="n">A</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tmp</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>二元运算符（+、-等）：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">//并不涉及返回值再次被赋值的问题，返回类型不需要是引用类型</span>
<span class="n">A</span><span class="w"> </span><span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">tmp</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ul>
<li>赋值运算符（=、+=、-=等）：要注意的是为了防止3=a这种语句的出现，编译器要求operator=必须是类内成员，且为了支持连续赋值的操作，赋值运算符的返回值应该是引用类型。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">//c++中支持连续赋值，如a=b=c=1相当于分别执行c=1,b=c,a=b</span>
<span class="c1">//为了支持连续赋值的操作，赋值运算符重载的返回值应该是引用类型</span>
<span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<ul>
<li>自增自减运算符（++、--）：要注意的是前置运算符和后置运算符使用一个参数int区分，该int仅起到区分的作用没有实际意义。同时为了和c++的自带类型相一致，最好前置运算符返回引用类型，后置运算符返回const类型。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">//前置运算符和后置运算符的区别：</span>
<span class="c1">//a++表示a先参与运算再自增，++a表示a先自增再参与运算</span>
<span class="k">class</span><span class="w"> </span><span class="nc">A</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="c1">//前置运算符和后置运算符使用参数int区分</span>
<span class="w">    </span><span class="n">A</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">++</span><span class="p">();</span><span class="c1">//前置运算符，对应于++a</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span><span class="c1">//后置运算符，对应于a++</span>
<span class="p">};</span><span class="w"></span>
<span class="c1">//c++中的自带类型，如int，允许++++a的语法，但不允许a++++的语法</span>
<span class="c1">//因此前置运算符应该返回引用类型支持连续自增，后置运算符应返回const类型拒绝连续自增</span>
<span class="n">A</span><span class="o">&amp;</span><span class="w"> </span><span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">A</span><span class="o">::</span><span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_29">虚函数<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h2>
<p>虚函数的必要性在于：
- 支持派生类中重写基类中的同名同参数函数
- 支持动态联编：基类的指针、引用也可以指向派生类对象，静态联编时基类的指针只会调用基类的函数，而动态联编中基类的指针可以根据运行时实际指向的对象类型动态调用对应类中的函数</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">phone</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">call</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="c1">//virtual关键字只在类声明中标识，函数实现时不能带有</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">phone::call</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">mobile_phone</span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">phone</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="c1">//只要基类中函数标识为了虚函数，派生类中的同名函数无论是否说明都自动为虚函数</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">call</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</code></pre></div>
<ul>
<li>为了析构函数的正确调用，有继承关系时析构函数必须是虚函数</li>
<li>构造函数不能是虚函数</li>
</ul>
<h2 id="_30">纯虚函数<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h2>
<p>纯虚函数和虚函数的区别在于，派生类可以不重写虚函数，直接继承，而纯虚函数要求派生类将其重写。</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Base</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="c1">//用virtual .. =0表示纯虚函数</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">func</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">//纯虚函数可以有函数体，虽然终究会被重写，但是派生类的函数可以调用</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Base</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">//纯虚的析构函数必须有函数体，否则派生类的析构函数在自动调用时会出错</span>
<span class="n">Base</span><span class="o">::~</span><span class="n">Base</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<h2 id="_31">抽象类<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h2>
<ul>
<li>一个类只要含有纯虚函数，那么它就是抽象类。</li>
<li>抽象类无法声明对象。</li>
</ul>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="页脚" >
      
        
        <a href="../../C/C%E5%9F%BA%E7%A1%80/" class="md-footer__link md-footer__link--prev" aria-label="上一页: C基础" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                上一页
              </span>
              C基础
            </div>
          </div>
        </a>
      
      
        
        <a href="../%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="md-footer__link md-footer__link--next" aria-label="下一页: 面向对象程序设计" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                下一页
              </span>
              面向对象程序设计
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.expand", "search.suggest", "search.highlight"], "search": "../../../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.config.lang": "ja", "search.config.pipeline": "trimmer, stemmer", "search.config.separator": "[\\s\\-\uff0c\u3002]+", "search.placeholder": "\u641c\u7d22", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version.title": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.d6c3db9e.min.js"></script>
      
        <script src="../../../mkdocs/javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>