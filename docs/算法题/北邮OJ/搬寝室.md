#动态规划 

## 题目描述

搬寝室是很累的,xhd深有体会.时间追述2006年7月9号,那天xhd迫于无奈要从27号楼搬到3号楼,因为10号要封楼了.看着寝室里的n件物品,xhd开始发呆,因为n是一个小于2000的整数,实在是太多了,于是xhd决定随便搬2k件过去就行了.但还是会很累,因为2k也不小是一个不大于n的整数.幸运的是xhd根据多年的搬东西的经验发现每搬一次的疲劳度是和左右手的物品的重量差的平方成正比(这里补充一句,xhd每次搬两件东西,左手一件右手一件).例如xhd左手拿重量为3的物品,右手拿重量为6的物品,则他搬完这次的疲劳度为(6-3)^2 = 9.现在可怜的xhd希望知道搬完这2*k件物品后的最佳状态是怎样的(也就是最低的疲劳度),请告诉他吧.

## Input

每组输入数据有两行,第一行有两个数n,k(2<=2*k<=n<2000).第二行有n个整数分别表示n件物品的重量(重量是一个小于2^15的正整数).

## Output

对应每组输入数据,输出数据只有一个表示他的最少的疲劳度,每个一行.

## 输入样例

```text
2 1
1 3
```

## 输出样例

```text
4
```

## 题解

将物品按重量排序，每次搬运的两件物品必定在原排序中是相邻的，原因在于假设a<b<c<d，则有(a-b)^2+(c-d)^2 < (a-c)^2+(b-d)^2, (a-b)^2+(c-d)^2 < (a-d)^2+(b-c)^2。
接下来利用动态规划求解，用dp[i][j]记录前j件物品搬运i对时的最小值，状态转移方程为dp[i][j]=min(dp[i-1][j-2]+(d[j]-d[j-1])^2, dp[i][j-1])。

```c++
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,k,d[2000],dp[1000][2000];
    while(scanf("%d%d",&n,&k)==2)
    {
        memset(dp,0,sizeof(dp));
        for(int i=1;i<=n;i++)
            scanf("%d",&d[i]);
        sort(d+1,d+n+1);
        for(int i=1;i<=k;i++)
        {
            dp[i][2*i]=dp[i-1][2*i-2]+(d[2*i]-d[2*i-1])*(d[2*i]-d[2*i-1]);
            for(int j=2*i+1;j<=n;j++)
                dp[i][j]=min(dp[i-1][j-2]+(d[j]-d[j-1])*(d[j]-d[j-1]),dp[i][j-1]);
        }
        printf("%d\n",dp[k][n]);
    }
    return 0;
}
```