# 快速排序

## 代码

```c++
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

## 思考

1. 如何分界？分治的时候是以i还是j作为划分？假设以i划分，是划分为(l, i - 1), (i, r)还是(l, i), (i+1, r)？

   考虑这个问题，主要是为了避免分治时范围没有任何变化，造成死循环。例如，假设某次循环结束后，i仍然在l的位置，而我们的划分方式是(l, i - 1), (i, r)，则划分后的右半部分还是(l, r)，这样就出现了死循环。

   要避免死循环，首先要思考的问题是，i，或者j，最终会处在什么位置？出现在数组中间的情况肯定不会造成死循环。出现在两边的情况，由于i和j是对称的，我们先考虑以i为分界点时，i可能出现在什么位置。

   - i是否可能保持在最左端？i出现在最左端时(l, i - 1), (i, r)的划分方式就会产生死循环。i位置不变的唯一情况就是，以a[l]为基准元素，且a[l]右边的元素都大于x。这要求基准元素选取在最左端。
   - i是否可能出现在最右端？i出现在最右端时(l, i), (i+1, r)的划分方式就会产生死循环。无论基准元素选在什么位置都有可能出现这种情况，例如：当排序对象只剩两个，且这两个数相等时。

   这么看来，想要避免死循环，以i为分界点时必须让基准元素的选取不在最左端，同时以(l, i - 1), (i, r)为划分方式。对称的，以j为分界点时必须让基准元素的选取不在最右端，同时以(l, j), (j + 1, r)为划分方式。

2. 基准元素位置的选择：首先根据前面的分析，以i为分界点划分时基准元素不要选在最左端，以j为分界点划分时基准元素不要选在最右端。随机选取基准元素可以避免这种情况，因为随机选取时不可能每次都选在最左端/最右端。

   此外，当数据特别规律，如数据大小为逆序，要排列为顺序时，基准元素x定为最左边，以j为分界点时会效率极低。同理，定为最右边也有这种问题。使用随机选取位置，或选中间点可以避免。注意选取中间点时，是向上取整还是向下取整要和划分方式匹配。

# 归并排序

# 两种排序方式的对比

- 时间上，快速排序并不稳定，特殊数据下时间甚至可能达到$O(n^2)$，而归并排序的时间稳定在$O(\log n)$
- 空间上，快速排序无需额外的数组空间，而归并排序需要开辟一块新的空间用于中转。
- 稳定性上，对于多个相等的元素，快速排序执行后他们的相对次序可能发生改变，而归并排序执行后他们的相对次序不会改变。
