# 机器指令

# 1.寄存器

![整数寄存器，用于存储整数数据和指针](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_15.32.53-3898773.png)

整数寄存器，用于存储整数数据和指针

- 栈指针 %rsp
- 返回值 %rax
- 函数参数 %rdi, %rsi, %rdx, %rcx, %r8, %r9
- 调用者保存的寄存器 %r10, %r11
- 被调用者保存的寄存器 %rbx, %r12, %r13, %r14

# 2.数据的访问与存储

## 1.数据格式

![截屏2021-11-25 15.38.26.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_15.38.26.png)

汇编后缀b/w/l/q用于表示操作数的字长，由于是从16位体系继承而来，b/w/l/q分别表示1字节（byte字节）、2字节（word字）、4字节（long双字）、8字节（quad四字）

对于浮点数，分别使用后缀s、l表示4字节单精度浮点数、8字节双精度浮点数。浮点数使用的寄存器不同，因此不会产生后缀之间的冲突。

## 2.操作数指示符

![截屏2021-11-25 16.05.31.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_16.05.31.png)

操作数operand分为三种：

- 立即数immediate

`$+整数，如$0x1F`

- 寄存器register

`%+寄存器名，如%rax`

- 内存引用memory reference

(地址)，如(%rax)，或偏移量+(地址)，如0x1f(%rax)

内存引用标准格式：$Imm(r_b,r_i,s)$

$Imm$表示立即数偏移，$r_b$表示基址寄存器（数组起始地址），$r_i$表示变址寄存器（数组下标），$s$表示比例因子（数组元素的字节数）

有效地址被计算为$Imm+R[r_b]+R[r_i]*s$，$R[*]$表示寄存器*中的值

## 3.数据传送指令

- movq Source, Dest(movl/movw/movb)

用于立即数、寄存器、内存之间的数据移动（不能从内存到内存）

![截屏2021-11-25 17.30.39.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_17.30.39.png)

四字节指令，如movl，以寄存器为目的时寄存器高四位字节会自动被置0

movq指令，以立即数为原操作数时，立即数也只能是补码形式的32位值

- movabsq I, R

原操作数、目的只能是64位立即数、寄存器，用于64位寄存器的传送

- movz** S, R

源值比目的短时使用，z表示对目的的高位做0拓展

![截屏2021-11-25 17.52.36.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_17.52.36.png)

- movs** S, R

同上，但做的是符号拓展

![截屏2021-11-25 17.53.23.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_17.53.23.png)

- cltq

将%eax做符号拓展到%rax

## 4.加载有效地址load effective address

$leaq$ $Imm(r_b,r_i,s)$, $R$

类似于对内存寻址然后将数据移动到寄存器的mov指令，不同在于leaq指令传送的是地址值，并不会实际调用内存

目的操作数只能是寄存器

常用于计算普通的算数操作，如:

leaq (%rdi, %rsi, 4), %rax 计算rdi+rsi*4

# 3.数据的计算

![整数运算操作，leaq常用于简单算数计算，ATT格式的汇编代码中操作数的顺序一般与直觉相反](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_20.18.04.png)

整数运算操作，leaq常用于简单算数计算，ATT格式的汇编代码中操作数的顺序一般与直觉相反

## 1.一元运算

- 自增 inc D

如：incq (%rsp)表示使栈顶的8字节元素加1

- 自减 dec D
- 取负 neg D
- 取补 not D

## 2.二元运算

格式：操作名称 S, D

加add 减sub 乘imul 异或xor 或or 与and

操作：将两个操作数做运算的结果放入第二个操作数的位置

如：subq %rax, %rdx 指rdx=rdx-rax

## 3.移位操作

逻辑位移和算数位移的区别：

sal/shl 左移 补0

shr 逻辑右移 补0

sar 算数右移 补符号位(0或1)

移位量只能是%cl或立即数

移位量大于字长w时，效果为移位n mod w

## 4.特殊运算

![截屏2021-11-25 21.40.31.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_21.40.31.png)

通过将%rdx，%rax组合达到计算16字节（8字oct word）的目的

这里的imulq和上面imul中的imulq同名不同义：这里的imulq为单操作数指令，作用为将操作数与rax相乘，结果放入%rdx%rax组合寄存器中

divq指令计算%rdx:%rax除以立即数S，商保存到%rax，余数保存到%rdx

cqto没有操作数，作用为将rax做符号拓展到%rdx%rax组合寄存器，即用rax的符号位填满rdx

# 4.控制

## 1.条件码

![截屏2021-11-25 21.50.57.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_21.50.57.png)

常用的四个条件码(condition code)寄存器，用于记录最近的操作的结果情况：

CF 进位、借位(carry)(无符号数)

ZF 结果为0(zero)

SF 负数(sign)(有符号数)

OF 溢出(overflow)(有符号数)

3中的指令都会更新这四个条件码，只有leaq除外，因为leaq计算的是地址，因此不会改动条件码

## 2.比较、测试指令

![截屏2021-11-25 22.36.46.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_22.36.46.png)

对两个数进行减法、与运算，根据结果更新条件码(不会变动操作数)

例如：testq %rax, %rax用于检查%rax是否为正、负或0

## 3.SET指令

SET指令根据其后缀，检查对应条件码，结果保存到目的位置（0或1）

目的位置只能是一个字节，例如：setl %al

![截屏2021-11-25 22.54.50.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_22.54.50.png)

上一个操作为无符号数、有符号数时，由于进位、溢出条件码不同，所用指令后缀也不同：

有符号数比较使用后缀g(greater)或l(less)检查OF、SF

无符号数比较使用后缀a(above)或b(below)检查CF

## 4.跳转指令

![截屏2021-11-25 23.14.31.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_23.14.31.png)

直接跳转：跳转目标用标号表示，如：jmp .L1

间接跳转：需要读取寄存器或内存得到跳转目标，操作数为*号加地址(同2.2中的操作数指示符) 如：

jmp *%rax 以rax的内容为跳转地址

jmp *(%rax) 以rax的内容为存储跳转地址的内存地址

## 5.条件分支

实现if…else…的两种方法：条件控制、条件传送

### 1.条件控制(条件跳转)

使用条件跳转指令实现分支，类似goto语句

![截屏2021-11-25 23.41.50.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_23.41.50.png)

### 2.条件传送

先顺序执行所有分支，再执行条件传送，将符合判断条件的数据传送，实现分支

![截屏2021-11-25 23.43.52.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_23.43.52.png)

原因：更符合CPU的流水线工作方式

缺点：分支之间起冲突、某一分支可能运行非法（如访问空指针）等情况时无法使用 分支运算过于复杂时会损失性能

![条件传送指令](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-25_23.55.53.png)

条件传送指令

## 6.循环

### 1.do-while

循环体后面加条件跳转语句

```c
loop:
	body-statement
	t = test-expr;
	if (t)
		goto loop;
```

### 2.while

两种方式在do-while的基础上改为while：

- 跳到中间jump to middle：直接跳转到循环体后的测试语句

```c
	goto test;
loop:
	body-statement
test:
	t = test-expr;
	if (t)
		goto loop;
```

- guarded-do：循环体前增加一次测试

```c
t = test-expr; 
if (!t)
	goto done;
loop:
	body-statement
	t = test-expr;
	if (t)
		goto loop;
done:
```

### 3.for

转化为while循环：

```c
init-expr;
while (test-expr)
{
	body-statement
	update-expr;
}
```

特例：使用continue语句时update-expr会被跳过，这种情况下上面的转换方式不适用

## 7.switch语句

跳转表jump table：存储机器代码地址的数组

使用条件：switch分支较多，跨度范围小

```c
void switcher(long a, long b, long c, long *dest)
{
	long val;
	switch(a)
	{
	case 5:
		c = b ^ 15;
		/* Fall through */
	case 0:
		val = c + 112;
		break;
	case 2:
	case 7:
		val = (c + b) << 2;
		break;
	case 4:
		val = a;
		break;
	default:
		val = b;
	}
	*dest = val;
}
```

![截屏2021-11-26 01.05.47.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-26_01.05.47.png)

# 5.过程

## 1.栈

### 1.特性

- 后进先出
- 向下增长 即：栈底地址最大，栈顶地址最小

### 2.压入和弹出数据

![截屏2021-11-26 01.17.47.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-11-26_01.17.47.png)

push：S入栈，rsp减8

pop：栈顶数据移动到D，rsp加8（只改变%rsp，栈中的数据不动）

### 3.运行时栈

![Untitled](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/Untitled.png)

- 栈顶到栈底地址依次增加
- 当前函数的栈帧内放置需要使用的寄存器中原有的数据、局部变量、参数构造区（下一个要调用的函数的参数）
- 调用者的栈帧内保存当前函数的第七个及后续参数、返回地址

## 2.转移控制

![截屏2021-12-24 22.36.57.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-12-24_22.36.57.png)

转移控制的方法：将程序计数器PC设置为要调用的新函数的地址。

- call指令：实现函数调用，具体方式为：push返回地址，修改PC到要执行的代码的位置。
- ret指令：返回到上一个位置，具体方式为：pop返回地址，修改PC到该返回地址。

## 3.传送数据

### 参数传递

函数的前六个参数保存在寄存器中，依次为%rdi, %rsi, %rdx, %rcx, %r8, %r9。

![截屏2021-12-24 22.47.46.png](media/%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4/%E6%88%AA%E5%B1%8F2021-12-24_22.47.46.png)

函数参数超过六个的部分通过栈传递

### 返回值

保存在寄存器%rax

## 4.栈上的局部存储