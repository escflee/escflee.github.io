# 数据处理

# 1.位运算

## 1.布尔运算

| 与 A&B | 或 A｜B |
|---|---|
| 非 ~A | 异或 A^B |

位向量表示集合：aj = 1 if j ∈ A

- 01101001 {0,3,5,6}
- 7**65**4**3**21**0**

## 2.位移运算

x<<n x左移n位，补0

x>>n(逻辑右移) x右移n位，补0

x>>n(算数右移) x右移n位，补符号位(0或1)

# 2.整数表示

## 1.无符号数

Unsigned

与普通的二进制表示数的方法相同

![截屏2021-11-22 21.20.25.png](media/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%88%AA%E5%B1%8F2021-11-22_21.20.25-3898834.png)

## 2.有符号数

Two's Complement

以最高位为符号位，为0表示正数，为1时表示负数

计算时，最高位权重不变，但取负值，其余位不变

表达范围不对称：
$TMax=2^{w-1}-1, TMin=-2^{w-1}$

如：8位二进制数最大值为01111111，最小值为10000000

![截屏2021-11-22 21.24.19.png](media/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%88%AA%E5%B1%8F2021-11-22_21.24.19.png)

![截屏2021-11-22 21.26.36.png](media/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%88%AA%E5%B1%8F2021-11-22_21.26.36.png)

## 3.无符号数与补码的转化

转换方式：每比特数均不变，直接转译

![截屏2021-11-22 21.39.04.png](media/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%88%AA%E5%B1%8F2021-11-22_21.39.04.png)

最高位为1时转译时会发生数据变化，加或减$2^w$

## 4.C语言中的无符号数与有符号数

默认为有符号，除非特殊声明，如以'U'为数的后缀

显式、隐式转换时的规则同上

表达式中同时包含时两者时，**有符号数自动转为无符号数，在比较大小时会出现问题**

## 5.扩展与截断

**扩展**：无符号数使用零扩展zero extension，有符号数使用符号扩展sign extension

零扩展：将新数的高位添0

符号扩展：将原数的符号位填满新数的高位

数值不会变化

**截断**：直接舍弃多余的高位truncating

对于无符号数：等效于取模运算

对于有符号数：等效于先视作无符号数取模，再重新转译

# 3.整数运算

## 1.无符号加法

和大于等于$2^w$时发生溢出，结果等于预期结果$-2^w$

![截屏2021-11-22 22.32.12.png](media/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%88%AA%E5%B1%8F2021-11-22_22.32.12.png)

## 2.补码加法

和大于$TMax=2^{w-1}-1$时发生正溢出，结果为预期结果$-2^w$（正变负）

和小于$TMin=-2^{w-1}$时发生负溢出，结果为预期结果$+2^w$（负变正，$TMin+TMin$等于0）

![截屏2021-11-22 22.57.23.png](media/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%88%AA%E5%B1%8F2021-11-22_22.57.23.png)

## 3.补码的相反数

$TMin$的相反数还是其本身，其余数能得到预期结果

位运算：按位取非，再加一

## 4.乘法

- 无符号乘法

结果为预期结果取模

- 补码乘法

结果为预期结果取模，再执行$U2T$（即对结果做有符号截断）

- 乘以常数

转化为先做移位，再做加法，如$x*14=(x<<4)-(x<<1)$

## 5.除法

逻辑右移/算数右移：逻辑右移左添0，算数右移左添符号位

- 除以2的幂的无符号除法

进行逻辑左移，结果为预期值向下取整

- 除以2的幂的补码除法

进行逻辑左移，结果为预期值向下取整

- 通过添加偏置biasing使得结果为预期值向上取整

在除以$2^k$之前$+2^k-1$，C语言描述为$(x+(1<<k)-1)>>k$

# 4.浮点数

## 1.小数的指数表示格式

$(-1)^SM2^E$

S：符号位

M：范围为[1.0,2.0)的小数

E：2的阶数

## 2.IEEE浮点表示格式

![截屏2021-11-23 00.31.24.png](media/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%88%AA%E5%B1%8F2021-11-23_00.31.24.png)

单精度浮点数float：符号位、阶码、小数分别占1、8、23位

双精度浮点数double：符号位、阶码、小数分别占1、11、52位

### （1）规格化的值

特点：阶码不全为0，也不全为1

- 阶码的偏置

对原数的阶数整体加偏置值Bias得到浮点表示中的exp，即翻译时原数的阶码$E=exp-Bias$

$Bias=2^{k-1}-1$，k为阶码的位数，如：8为阶码的偏置为01111111

- 小数部分的表示

截取原数的M的小数部分（整数部分1忽略）即翻译时原数的小数部分$M=1.frac$

### （2）非规格化的值

用于表示0以及非常接近0的数

特点：阶码全为0

- 阶码的值

翻译时原数的阶码取$E=exp-Bias+1$，即$1-Bias$

原因：从最小的规格化数到非规格化数时，同时阶码减1、小数部分减1，会导致数值的变化不平滑，因此从最小的规格化数到非规格化数转换时阶码不变，只变小数部分

- 小数部分的表示

翻译时小数部分不加整数1，即$M=0.frac$

- 0的表示

符号位为0或1，其余位全部为0

### （3）特殊值

特点：阶码全为1

- 小数域全为0

表示正无穷$+∞$或负无穷$-∞$，通常指溢出，如除以0

- 小数域不为0

表示"NaN"，即Not a Number，可以指结果为虚数、$∞-∞$、未初始化等

![截屏2021-11-23 01.32.43.png](media/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%88%AA%E5%B1%8F2021-11-23_01.32.43.png)

## 3.舍入

IEEE浮点格式规定的四种舍入方式：

（1）（默认）向偶数舍入round-to-even，又称向最近的值舍入round-to-nearest

（2）向零舍入

（3）向下舍入

（4）向上舍入

## 4.浮点运算

一般情况下加减法运形成阿贝尔群，但对于浮点运算：

- 逆元

无穷不存在逆元，因为$-∞+∞=NaN$

NaN不存在逆元，因为NaN与任何数相加仍等于NaN

- 结合性

浮点运算不存在结合律，因为存在舍入的问题

- 单调性

不同于无符号数、补码的加法，浮点运算满足单调性属性，即对于不为NaN的数，都有若$a>=b$，则$x+a>=x+b$

# 5.信息存储

## 1.字数据大小

字长word size：表明指针的标称大小nominal size，即指针的长度，决定程序所能访问的字节数

## 2.字节顺序

对于跨越多个字节的数据，其地址为使用的所有字节中最小的地址

从地址从小到大，数据的排序方式可分为：

小端法little endian：从数据的最低有效字节开始依次存入内存

大端法big endian：从数据的最高有效字节开始依次存入内存

如对于四字节数0x01234567:

![截屏2021-11-23 00.18.51.png](media/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/%E6%88%AA%E5%B1%8F2021-11-23_00.18.51.png)