
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.2, mkdocs-material-8.5.10">
    
    
      
        <title>地址转换 - escflee</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.472b142f.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.08040f6c.min.css">
        
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="None" data-md-color-accent="None">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="escflee" class="md-header__button md-logo" aria-label="escflee" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            escflee
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              地址转换
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="escflee" class="md-nav__button md-logo" aria-label="escflee" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    escflee
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1">
          课程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="课程" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          课程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_1" type="checkbox" id="__nav_1_1" >
      
      
      
      
        <label class="md-nav__link" for="__nav_1_1">
          操作系统
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="操作系统" data-md-level="2">
        <label class="md-nav__title" for="__nav_1_1">
          <span class="md-nav__icon md-icon"></span>
          操作系统
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" class="md-nav__link">
        文件管理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="md-nav__link">
        进程管理
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    逻辑地址，物理地址
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#mmu" class="md-nav__link">
    MMU
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="_1">地址转换</h1>
<p>如果程序在编译时就已经知道了程序将会处在内存中的什么位置，那么直接在程序中写入实际内存的地址就可以了。而实际上这是不可能的，在多进程系统中程序每次执行时在内存中所处的位置都可能不一样。考虑到进程会被挂起、重启的情况，程序所处的地址甚至还会在运行途中发生变化。</p>
<p>因此，可以在编译程序时不把地址写死，而是在加载程序时，或运行程序时再计算实际地址。</p>
<h2 id="_2">逻辑地址，物理地址</h2>
<p>CPU生成的地址称为逻辑地址(logical address)，而内存单元看到的地址称为物理地址(physical address)。</p>
<h2 id="mmu">MMU</h2>
<p>虚拟地址到逻辑地址的映射是由硬件完成的，称该部件为内存管理单元(Memory-Management Unit, MMU)。根据实际的内存分配方式不同，MMU的结构也不同，</p>
<p>一种最简单的内存分配方式是，为每个进程分配一块连续的空间，MMU用重定位寄存器(relocation register)存储进程的开始地址，程序中的逻辑地址为相对地址，MMU只需要将逻辑地址与开始地址相加就能得到物理地址。</p>
<h1 id="_3">内存分配</h1>
<p>在介绍实际的内存分配方式之前，先解决一些内存分配中的基本问题，它们是连续内存分配、分段、分页、虚拟内存等内存分配方式的基础。</p>
<h2 id="_4">分区方式</h2>
<p>按什么方式来将内存进行分区，方法包括：</p>
<ul>
<li>固定大小分区</li>
<li>可变分区(variable-partition)：分区大小不固定，操作系统记录哪些位置空闲(孔, hole)，哪些位置已用。</li>
</ul>
<h2 id="_5">分配方式</h2>
<p>当新进程需要内存时，选择将哪个孔分配给它的办法，包括：</p>
<ul>
<li>首次适应(first-fit)：分配首个足够大的孔</li>
<li>最优适应(best-fit)：分配最小的足够大的孔，目的在于使碎片最小。</li>
<li>最差适应(worst-fit)：分配最大的孔，目的在于使碎片尽可能可用。</li>
</ul>
<h2 id="_6">碎片</h2>
<p>总的可用空间连续，但因过于分裂而无法使用的情况就是碎片。碎片包括：</p>
<ul>
<li>内部碎片(internal fragmentation)：分配给了进程，但进程用不上的空间。</li>
<li>外部碎片(external fragmentation)：没有分配给进程，但无法使用的空间。</li>
</ul>
<p>解决碎片的方法包括：</p>
<ul>
<li>紧缩(compaction)：移动已有的内容，以整合碎片。</li>
<li>允许进程使用多个不连续的空间，如分段、分页。</li>
</ul>
<h2 id="_7">交换</h2>
<p>程序必须在内存中才可以运行，但可以暂时将程序数据移入磁盘以腾出内存空间，需要的时候再取回，以提升系统的多道程序程度。需要注意的问题包括：</p>
<ul>
<li>正在等待I/O或其他事件的进程不应该被移出。</li>
<li>频繁的交换可能造成磁盘的过度损耗。</li>
<li>交换非常耗时，应该在必要时才使用，同时可以采用只交换部分数据的方式提高效率。</li>
</ul>
<h1 id="_8">连续内存分配</h1>
<p>contiguous memory allocation，为每个进程分配的空间都是连续的，是一种非常初级的分配方式，但可以解决内存保护和地址绑定的问题。</p>
<h2 id="_9">地址转换</h2>
<p>代码中的地址均为相对地址，由MMU在运行时添加上起始地址得到物理地址。</p>
<p><img alt="image-20221121195212025" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121195212025.png" /></p>
<h2 id="_10">内存保护</h2>
<p>为了防止进程访问到不属于自己的空间，可以使用界限寄存器、重定位寄存器分别记录进程内存的长度和起始地址，每次访问内存都判断地址是否在这个范围内。</p>
<p><img alt="image-20221121194941478" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121194941478.png" /></p>
<h1 id="_11">分段</h1>
<p><code>第十版教材中删掉了这部分内容</code></p>
<p>将程序划分为多个段进行存储，例如堆栈段、程序段、数学库段。每个段可以不连续、大小可以不同。</p>
<h2 id="_12">地址转换</h2>
<ul>
<li>
<p>地址的表示通过&lt;段号，偏移&gt;的有序对表示。</p>
</li>
<li>
<p>分段通过段表(segment table)进行存储，段表的每个条目都有段基地址(segment base)和段界限(segment limit)两部分，分别表示起始位置和长度。</p>
</li>
<li>
<p>由MMU完成&lt;段号，偏移&gt;的逻辑地址到物理地址的转换。</p>
</li>
</ul>
<p><img alt="image-20221121201421945" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121201421945.png" /></p>
<h1 id="_13">分页</h1>
<p>将内存分为同样大小的块，称为帧或页帧(frame)，而逻辑内存也分为同样大小的块，称为页或页面(page)。每个页都可以分配到任意的帧上存储。这种方法灵活、寻址方便，还避免了外部碎片，是最常用的方法。</p>
<h2 id="_14">地址转换</h2>
<ul>
<li>页的大小为2的整数次幂，因此逻辑地址仍然用一个二进制数表示，但前一部分表示页码，后一部分表示页内偏移。</li>
</ul>
<p><img alt="image-20221121203016987" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121203016987.png" /></p>
<ul>
<li>
<p>用页表(page table)存储页码到物理地址的转换关系。页表的下标为页码，内容为该页在内存中的起始位置（如果在内存中）。每个进程都有自己独立的页表。</p>
</li>
<li>
<p>用帧表(frame table)存储内存的每个帧是否被占用、被哪个进程的哪一页占用。整个系统只有一个帧表。</p>
</li>
<li>
<p>由MMU将逻辑地址的页码转换为物理帧号，实现逻辑地址到物理地址的转换。</p>
</li>
</ul>
<p><img alt="image-20221121203239904" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121203239904.png" /></p>
<h2 id="_15">页表存储</h2>
<ul>
<li>对于较小的页表，可以用专用寄存器存储。而对于很大的页表，只能将其存储在内存中。</li>
<li>页表基地址寄存器(Page-Table Base Register, PTBR)：用于指向页表在内存中的位置。这样，切换进程时只需要更改PTBR，而不是整个页表。</li>
<li>可以用页表长度寄存器(Page-Table Length Register, PTLR)来存储页表的长度，防止访问页表中不存在，即未定义的空间。</li>
<li>除页码和帧号外，页表的每一项还可以存储其他信息，如：可以用有效-无效位记录页是否为空，或是否被调入了内存。再比如，可以记录每个页是只读的还是可读写的。</li>
</ul>
<h2 id="tlb">TLB</h2>
<p>页表存储在内存中会导致每次内存读写都需要访问两次内存，解决方法是单独设立一个页表的高速缓存，称为转换表缓冲区(Translation Look-aside Buffer, TLB)。</p>
<p><img alt="image-20221121210439999" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121210439999.png" /></p>
<ul>
<li>地址转换时首先访问TLB。TLB未命中(TLB miss)时，再访问页表，然后把得到的结果存入TLB。</li>
<li>若装入新条目时TLB已满，可以使用LRU等策略替换。</li>
<li>有的TLB允许固定下(wired down)特定条目，如内核关键代码的条目。</li>
<li>TLB可以有两个(代码一个，数据一个)，但不可能做到一个进程一个。因此有的TLB还存储地址空间标识符(Address-Space Identifier, ASID)，即每一项所属的进程。这样做可以让多个进程共用TLB，以及提供进程间的内存保护。</li>
<li>对于不支持ASID的页表，切换进程时应该被整个刷新。</li>
</ul>
<h2 id="_16">共享</h2>
<p>对于可共享的数据或代码，可以通过让不同进程的页表映射到同一物理地址，实现共享访问。这样可以实现通用代码的共用、进程间通信等功能。</p>
<h2 id="_17">页表结构</h2>
<ul>
<li>分层分页(hierarchical paging)</li>
</ul>
<p><img alt="image-20221121213633192" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121213633192.png" /></p>
<ul>
<li>哈希页表(hashed page table)：可以用来将一个过大的页码空间映射到较小的空间，解决稀疏(sparse)页表占用空间过大的问题。</li>
</ul>
<p><img alt="image-20221121213855812" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121213855812.png" /></p>
<ul>
<li>倒置页表(inverted page table)：整个系统只使用一个页表，而不是一个进程一个。页表中只存储真正在物理内存中存在的页。地址变换时需要查找整张表，找到进程号和页码都匹配的项。可以使用哈希页表优化。</li>
</ul>
<p><img alt="image-20221121214914036" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121214914036.png" /></p>
<h1 id="_18">虚拟内存</h1>
<h2 id="_19">作用</h2>
<p>虚拟内存的出现背景在于，程序运行时很多东西都是没有必要实际放入内存的，如：</p>
<ul>
<li>很少执行的代码并不需要实际调入内存。</li>
<li>数组、链表等结构可能声明了很大的空间，却只使用一小部分，另一部分可以不用实际在内存中存储。</li>
</ul>
<p>虚拟内存的作用就在于，让每个进程以为自己可以使用的内存空间依然是一整大块，而数据实际上在内存中可能是碎片化的、甚至根本就没有被载入内存，由操作系统在背后完成转换工作。这样做的好处包括：</p>
<ul>
<li>程序员不再需要考虑实际的内存大小和分配方式，可以把内存当作一大块可以随意使用的连续空间。</li>
<li>没有必要的数据不会被放入内存，这使得系统能够同时运行更多程序。</li>
<li>不同进程共用的代码和数据可以不用单独存储，共用相同的页就可以了，这也节约了内存的开销。</li>
</ul>
<h2 id="_20">实现</h2>
<ul>
<li>
<p>虚拟地址空间：基于分页式存储，采用页表、MMU将虚拟地址空间映射到实际地址。</p>
</li>
<li>
<p>请求调页(demand paging)：程序运行开始时不是将所有可能用到的页都调入，而是由操作系统预测会被使用的一部分调入。使用未调入内存的页时，发生缺页(page fault)，由操作系统将其从磁盘中读入内存。</p>
</li>
</ul>
<p>这种方法需要页表中使用有效-无效位来记录某一页是否已经被调入内存。</p>
<p><img alt="image-20221121215835237" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121215835237.png" /></p>
<ul>
<li>页面置换：当内存不足时，不是选择将某个进程整个挂起，而是选择某一页，将其换出。</li>
</ul>
<p>可以使用修改位(modify bit, 或称脏位, dirty bit)存储每个页面是否较磁盘中的被修改过，置换页面时优先选择没有被修改过的，这样就不需要写回磁盘了。</p>
<p><img alt="image-20221121220252067" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121220252067.png" /></p>
<h1 id="_21">虚拟内存算法</h1>
<h2 id="_22">页面置换算法</h2>
<p>需要置换页面时，选择牺牲哪个页面的算法。目标是缺页次数越少越好。需要注意Belady异常(Belady's anomaly)的问题：帧数增加，缺页次数反而增加。</p>
<ul>
<li>
<p>最优页面置换(optimal page-replacement algorithm)：置换接下来最长时间不会被使用的页面。</p>
</li>
<li>
<p>不会导致Belady异常</p>
</li>
<li>
<p>是理论上可以达到的最高效的算法，但是由于无法预知进程未来的调用序列，该算法无法实现</p>
</li>
<li>
<p>FIFO(First-In-First-Out)：置换最早被调入内存的帧。</p>
</li>
<li>
<p>可能导致Belady异常</p>
</li>
<li>
<p>LRU(Least-Recent-Used)：置换最长时间没有被使用的页。这种算法的思想是利用过去的信息对未来做预估，长时间没有被使用的页面将来也大概率不会被使用。</p>
</li>
<li>
<p>不会导致Belady异常</p>
</li>
<li>实现方式1：计数器/时钟，即为每个页表条目增加其上次使用持续/时间的存储，但每次换页都要搜索</li>
<li>
<p>实现方式2：使用堆栈存储页面的调用顺序，最近被访问的放置在栈顶，最长时间未被访问的放置在栈底。这种方法不需要搜索，但需要大量改动堆栈中的指针</p>
</li>
<li>
<p>近似LRU：内存中每个页都用一个移位寄存器记录使用情况，页被使用时将寄存器的最高位置1，同时周期性的将所有页面的寄存器右移一位，这样寄存器值最小的就是最久未使用的页（可能不唯一）。</p>
</li>
<li>
<p>第二次机会页面置换算法(second-chance page-replacement algotithm，也叫做时钟算法，clock algorithm)：可以看做是FIFO和近似LRU的结合。</p>
</li>
<li>
<p>系统存储一个按调入内存的顺序排序的页面队列，以及每个页面是否最近被调用过的引用位，每次调用都会将该位置1。</p>
</li>
<li>需要置换时系统从队首开始，遇到引用位为1的则将其引用位置0，移到队尾，遇到引用位为0的则将其置换。可以理解为是，引用位的1相当于一个一次性的“免死金牌”。</li>
<li>该方法在FIFO的基础上保证了最近经常被访问的页不会被置换出。</li>
</ul>
<p><img alt="image-20221121154248539" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221121154248539.png" /></p>
<ul>
<li>
<p>其他算法：</p>
</li>
<li>
<p>增强型二次机会算法：在第二次机会算法的基础上改进而来，将判断引用位改为了判断（引用位、修改位）的组合。</p>
</li>
<li>最不经常使用(Least Frequently Used, LFU)</li>
<li>最经常使用(Most Frequently Used, MFU)：这种算法有时候也是有用的，思想在于最近被调入但还没有怎么被使用的页可能马上就会被使用。</li>
</ul>
<h2 id="_23">帧的分配算法</h2>
<p>处理在多进程系统中，为每个进程分配多少个帧、发生缺页时置换哪个进程的帧等问题。</p>
<ul>
<li>最小帧数：根据机器使用的指令集，单个指令可能需要同时调用多个页，这决定了单个进程最少需要的帧数。如：一个移动指令可能指令横跨两页，数据来源横跨两页，数据目的地址横跨两页，共需要六页。</li>
<li>平均分配(equal allocation)和比例分配(proportional allocation)（按虚拟内存的大小比例）。</li>
<li>全局置换(global replacement)和局部置换(local replacement)，即是否允许进程缺页时牺牲其他较低优先级进程的帧。</li>
<li>对于非均匀内存访问(Non-Uniform Memory Access, NUMA)系统，即具有多个CPU和内存的系统，为进程页面分配帧时，帧所处的内存应该尽可能靠近执行进程的CPU。</li>
</ul>
<h1 id="_24">虚拟内存优化</h1>
<h2 id="_25">系统抖动</h2>
<p>抖动(Thrashing)：指由于给进程分配的帧不足，而导致频繁缺页的情况。抖动可能出现恶性循环：进程长时间等待换页，CPU利用率降低，此时调度程序开始更多程序的运行以提高CPU利用率，单个进程的可用帧数更加减少。因此普通的调度方案不能解决抖动问题。</p>
<ul>
<li>工作集模型(working-set model)：基于局部性假设，根据进程最近调用的$\Delta$个页的集合中页的个数，为进程分配帧数。</li>
<li>缺页错误频率(Page-Fault Frequency, PFF)：设定缺页频率的上下限，高于上限时为进程分配更多的帧，低于下限时减少进程的可用帧。</li>
</ul>
<h2 id="_26">写时复制</h2>
<p>写时复制(copy-on-write)：使用fork()创建新进程时子进程可以直接与父进程共用相同的页，要修改哪个页的时候再复制对应的页。</p>
<h2 id="_27">内存映射</h2>
<p>进程使用标准系统调用open()、read()、write()来访问磁盘文件时，可以采用内存映射(memory mapping)的方法，将磁盘文件映射到进程的虚拟内存空间。</p>
<ul>
<li>进程访问文件，等同于访问自己的虚拟内存，页并不实际存在于内存中时将其调入。</li>
<li>修改文件时先修改内存，页被调出时再将修改写回磁盘。</li>
<li>多个进程打开同一个文件时，这些进程的虚拟内存页指向物理内存的同一帧，该帧存储了磁盘上该文件的拷贝。可以使用写时复制的方法使得进程修改文件时生成独立的副本，不影响原文件。</li>
</ul>
<p>除了对文件的操作，对外部设备的I/O、数据传输等操作也都可以进行内存映射，例如，为显示器映射一块内存，显示文本就等同于在这块内存中写入数据。</p>
<h2 id="_28">内核内存</h2>
<p>内核对内存分配的要求不同于普通进程：</p>
<ul>
<li>内核有大量不足一页的数据结构，如果都按页分配内存会产生大量的内部碎片</li>
<li>有些硬件直接与物理内存交互，不经过虚拟内存，因此这部分的内存应该连续地常驻于内存的某个固定位置</li>
</ul>
<p>解决内核内存分配问题的方法包括：</p>
<ul>
<li>伙伴系统(buddy system)：将一块连续的内存分为2的整数次幂大小的块，每种大小的块单独存储，如系统为1KB、2KB、4KB等大小的块分别建立链表用于记录。</li>
</ul>
<p>分配内存时，找到一块大小最接近的内存块，没有则从更大的块中分离出来。例如对于一块256KB大小的内存，需要分配一个21KB的块，则系统首先将256KB分为两个128KB的块，再取一个128KB的块分解为两个64KB的块，最后得到32KB的块。</p>
<p>内存释放时执行逆过程，将较小的合并(coalesce)为更大的块。</p>
<p><img alt="image-20221123142101987" src="../media/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/image-20221123142101987.png" /></p>
<ul>
<li>slab分配：在伙伴分配器的基础上进一步细分。思路是，为每一种内核数据结构，如信号量、进程描述符等分配一个cache。每个cache由若干个slab组成。每个slab对应内存中若干个连续的页面，按照所存储的数据结构类型分为相同大小的块。</li>
</ul>
<p>这种分配方式的好处在于，对于每种数据结构，所处的位置都是已经分配好的。当这个数据结创建新的实例对象时可以随用随取，实例对象使用结束后将该块标记为空闲即可，内存不会被收回。这样便提高了分配速度，避免了内部碎片。</p>
<h2 id="_29">其他优化</h2>
<ul>
<li>页面缓冲：系统保留一个空闲帧缓冲池，使得发生缺页时有空闲帧可以立即使用，原有帧的置换可以留到后面再慢慢执行。</li>
<li>原始磁盘(raw disk)：某些应用，如数据库，比操作系统更能理解自己应该怎么分配存储，怎么缓存数据，操作系统中文件系统的介入反而会降低他们的速度。因此有些操作系统允许应用绕过文件系统，直接操纵磁盘分区。</li>
<li>增大TLB范围(TLB reach)，即可以通过TLB直接访问的内存大小，方法包括扩大TLB、提供更大的页。</li>
<li>倒置页表和普通页表结合，即一般情况下使用倒置页表，出现缺页时才将普通页表调入内存。</li>
<li>允许页面被锁定到内存中，从而避免正在进行I/O的页被换出、或低优先级进程所需的页好不容易被换入了，还没使用就又被高优先级进程换走的情况。</li>
</ul>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.16e2a7d4.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.d6c3db9e.min.js"></script>
      
    
  </body>
</html>